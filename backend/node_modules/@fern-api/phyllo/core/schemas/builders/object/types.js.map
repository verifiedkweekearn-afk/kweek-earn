{
  "version": 3,
  "sources": ["../../../../src/core/schemas/builders/object/types.ts"],
  "sourcesContent": ["import { inferParsed, inferRaw, Schema } from \"../../Schema\";\nimport { addQuestionMarksToNullableProperties } from \"../../utils/addQuestionMarksToNullableProperties\";\nimport { BaseObjectLikeSchema, ObjectLikeSchema } from \"../object-like\";\nimport { Property } from \"./property\";\n\nexport type ObjectSchema<Raw, Parsed> = BaseObjectSchema<Raw, Parsed> &\n  ObjectLikeSchema<Raw, Parsed> &\n  ObjectUtils<Raw, Parsed>;\n\nexport type BaseObjectSchema<Raw, Parsed> = BaseObjectLikeSchema<Raw, Parsed>;\n\nexport interface ObjectUtils<Raw, Parsed> {\n  extend: <RawExtension, ParsedExtension>(\n    schemas: ObjectSchema<RawExtension, ParsedExtension>\n  ) => ObjectSchema<Raw & RawExtension, Parsed & ParsedExtension>;\n}\n\nexport type inferRawObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<infer Raw, any> ? Raw : never;\n\nexport type inferParsedObject<O extends ObjectSchema<any, any>> = O extends ObjectSchema<any, infer Parsed>\n  ? Parsed\n  : never;\n\nexport type inferObjectSchemaFromPropertySchemas<T extends PropertySchemas<keyof T>> = ObjectSchema<\n  inferRawObjectFromPropertySchemas<T>,\n  inferParsedObjectFromPropertySchemas<T>\n>;\n\nexport type inferRawObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =\n  addQuestionMarksToNullableProperties<{\n    [ParsedKey in keyof T as inferRawKey<ParsedKey, T[ParsedKey]>]: inferRawPropertySchema<T[ParsedKey]>;\n  }>;\n\nexport type inferParsedObjectFromPropertySchemas<T extends PropertySchemas<keyof T>> =\n  addQuestionMarksToNullableProperties<{\n    [K in keyof T]: inferParsedPropertySchema<T[K]>;\n  }>;\n\nexport type PropertySchemas<ParsedKeys extends string | number | symbol> = Record<\n  ParsedKeys,\n  Property<any, any, any> | Schema<any, any>\n>;\n\nexport type inferRawPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<\n  any,\n  infer Raw,\n  any\n>\n  ? Raw\n  : P extends Schema<any, any>\n  ? inferRaw<P>\n  : never;\n\nexport type inferParsedPropertySchema<P extends Property<any, any, any> | Schema<any, any>> = P extends Property<\n  any,\n  any,\n  infer Parsed\n>\n  ? Parsed\n  : P extends Schema<any, any>\n  ? inferParsed<P>\n  : never;\n\nexport type inferRawKey<\n  ParsedKey extends string | number | symbol,\n  P extends Property<any, any, any> | Schema<any, any>\n> = P extends Property<infer Raw, any, any> ? Raw : ParsedKey;\n"],
  "mappings": ";;;;;;;;;;;;;;AAAA;AAAA;",
  "names": []
}
