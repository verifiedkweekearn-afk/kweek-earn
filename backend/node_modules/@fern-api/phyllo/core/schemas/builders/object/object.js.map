{
  "version": 3,
  "sources": ["../../../../src/core/schemas/builders/object/object.ts"],
  "sourcesContent": ["import { Schema } from \"../../Schema\";\nimport { entries } from \"../../utils/entries\";\nimport { getObjectLikeUtils, OBJECT_LIKE_BRAND } from \"../object-like\";\nimport { getSchemaUtils } from \"../schema-utils\";\nimport { isProperty } from \"./property\";\nimport {\n  BaseObjectSchema,\n  inferObjectSchemaFromPropertySchemas,\n  inferParsedObjectFromPropertySchemas,\n  inferRawObjectFromPropertySchemas,\n  ObjectSchema,\n  ObjectUtils,\n  PropertySchemas,\n} from \"./types\";\n\ninterface ObjectPropertyWithRawKey {\n  rawKey: string;\n  parsedKey: string | number | symbol;\n  valueSchema: Schema<any, any>;\n}\n\nexport function object<ParsedKeys extends string, T extends PropertySchemas<ParsedKeys>>(\n  schemas: T\n): inferObjectSchemaFromPropertySchemas<T> {\n  const baseSchema: BaseObjectSchema<inferRawObjectFromPropertySchemas<T>, inferParsedObjectFromPropertySchemas<T>> = {\n    ...OBJECT_LIKE_BRAND,\n\n    parse: (raw, { skipUnknownKeysOnParse = false } = {}) => {\n      const rawKeyToProperty: Record<string, ObjectPropertyWithRawKey> = {};\n\n      for (const [parsedKey, schemaOrObjectProperty] of entries(schemas)) {\n        const rawKey = isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.rawKey : parsedKey;\n\n        const property: ObjectPropertyWithRawKey = {\n          rawKey,\n          parsedKey,\n          valueSchema: isProperty(schemaOrObjectProperty) ? schemaOrObjectProperty.valueSchema : schemaOrObjectProperty,\n        };\n\n        rawKeyToProperty[rawKey] = property;\n      }\n\n      const parsed: Record<string | number | symbol, any> = {};\n\n      for (const [rawKey, rawPropertyValue] of Object.entries(raw)) {\n        const property = rawKeyToProperty[rawKey];\n\n        if (property != null) {\n          const value = property.valueSchema.parse(rawPropertyValue);\n          parsed[property.parsedKey] = value;\n        } else if (!skipUnknownKeysOnParse && rawPropertyValue != null) {\n          parsed[rawKey] = rawPropertyValue;\n        }\n      }\n\n      return parsed as inferParsedObjectFromPropertySchemas<T>;\n    },\n\n    json: (parsed, { includeUnknownKeysOnJson = false } = {}) => {\n      const raw: Record<string | number | symbol, any> = {};\n\n      for (const [parsedKey, parsedPropertyValue] of entries(parsed)) {\n        const schemaOrObjectProperty = schemas[parsedKey as keyof T];\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (schemaOrObjectProperty != null) {\n          if (isProperty(schemaOrObjectProperty)) {\n            const value = schemaOrObjectProperty.valueSchema.json(parsedPropertyValue);\n            raw[schemaOrObjectProperty.rawKey] = value;\n          } else {\n            const value = schemaOrObjectProperty.json(parsedPropertyValue);\n            raw[parsedKey] = value;\n          }\n        } else if (includeUnknownKeysOnJson && parsedPropertyValue != null) {\n          raw[parsedKey] = parsedPropertyValue;\n        }\n      }\n\n      return raw as inferRawObjectFromPropertySchemas<T>;\n    },\n  };\n\n  return {\n    ...baseSchema,\n    ...getSchemaUtils(baseSchema),\n    ...getObjectLikeUtils(baseSchema),\n    ...getObjectUtils(baseSchema),\n  };\n}\n\nexport function getObjectUtils<Raw, Parsed>(schema: BaseObjectSchema<Raw, Parsed>): ObjectUtils<Raw, Parsed> {\n  return {\n    extend: <RawExtension, ParsedExtension>(extension: ObjectSchema<RawExtension, ParsedExtension>) => {\n      const baseSchema: BaseObjectSchema<Raw & RawExtension, Parsed & ParsedExtension> = {\n        ...OBJECT_LIKE_BRAND,\n        parse: (raw, opts) => ({\n          ...schema.parse(raw, opts),\n          ...extension.parse(raw, opts),\n        }),\n        json: (parsed, opts) => ({\n          ...schema.json(parsed, opts),\n          ...extension.json(parsed, opts),\n        }),\n      };\n\n      return {\n        ...baseSchema,\n        ...getSchemaUtils(baseSchema),\n        ...getObjectLikeUtils(baseSchema),\n        ...getObjectUtils(baseSchema),\n      };\n    },\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,qBAAwB;AACxB,yBAAsD;AACtD,0BAA+B;AAC/B,sBAA2B;AAiBpB,gBACL,SACyC;AACzC,QAAM,aAA8G;AAAA,IAClH,GAAG;AAAA,IAEH,OAAO,CAAC,KAAK,EAAE,yBAAyB,UAAU,CAAC,MAAM;AACvD,YAAM,mBAA6D,CAAC;AAEpE,iBAAW,CAAC,WAAW,2BAA2B,4BAAQ,OAAO,GAAG;AAClE,cAAM,SAAS,gCAAW,sBAAsB,IAAI,uBAAuB,SAAS;AAEpF,cAAM,WAAqC;AAAA,UACzC;AAAA,UACA;AAAA,UACA,aAAa,gCAAW,sBAAsB,IAAI,uBAAuB,cAAc;AAAA,QACzF;AAEA,yBAAiB,UAAU;AAAA,MAC7B;AAEA,YAAM,SAAgD,CAAC;AAEvD,iBAAW,CAAC,QAAQ,qBAAqB,OAAO,QAAQ,GAAG,GAAG;AAC5D,cAAM,WAAW,iBAAiB;AAElC,YAAI,YAAY,MAAM;AACpB,gBAAM,QAAQ,SAAS,YAAY,MAAM,gBAAgB;AACzD,iBAAO,SAAS,aAAa;AAAA,QAC/B,WAAW,CAAC,0BAA0B,oBAAoB,MAAM;AAC9D,iBAAO,UAAU;AAAA,QACnB;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,IAEA,MAAM,CAAC,QAAQ,EAAE,2BAA2B,UAAU,CAAC,MAAM;AAC3D,YAAM,MAA6C,CAAC;AAEpD,iBAAW,CAAC,WAAW,wBAAwB,4BAAQ,MAAM,GAAG;AAC9D,cAAM,yBAAyB,QAAQ;AAEvC,YAAI,0BAA0B,MAAM;AAClC,cAAI,gCAAW,sBAAsB,GAAG;AACtC,kBAAM,QAAQ,uBAAuB,YAAY,KAAK,mBAAmB;AACzE,gBAAI,uBAAuB,UAAU;AAAA,UACvC,OAAO;AACL,kBAAM,QAAQ,uBAAuB,KAAK,mBAAmB;AAC7D,gBAAI,aAAa;AAAA,UACnB;AAAA,QACF,WAAW,4BAA4B,uBAAuB,MAAM;AAClE,cAAI,aAAa;AAAA,QACnB;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG,wCAAe,UAAU;AAAA,IAC5B,GAAG,2CAAmB,UAAU;AAAA,IAChC,GAAG,eAAe,UAAU;AAAA,EAC9B;AACF;AAEO,wBAAqC,QAAiE;AAC3G,SAAO;AAAA,IACL,QAAQ,CAAgC,cAA2D;AACjG,YAAM,aAA6E;AAAA,QACjF,GAAG;AAAA,QACH,OAAO,CAAC,KAAK,SAAU;AAAA,UACrB,GAAG,OAAO,MAAM,KAAK,IAAI;AAAA,UACzB,GAAG,UAAU,MAAM,KAAK,IAAI;AAAA,QAC9B;AAAA,QACA,MAAM,CAAC,QAAQ,SAAU;AAAA,UACvB,GAAG,OAAO,KAAK,QAAQ,IAAI;AAAA,UAC3B,GAAG,UAAU,KAAK,QAAQ,IAAI;AAAA,QAChC;AAAA,MACF;AAEA,aAAO;AAAA,QACL,GAAG;AAAA,QACH,GAAG,wCAAe,UAAU;AAAA,QAC5B,GAAG,2CAAmB,UAAU;AAAA,QAChC,GAAG,eAAe,UAAU;AAAA,MAC9B;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
